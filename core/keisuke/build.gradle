plugins {
  id 'java'
  //id 'eclipse'
  //id 'maven'
  id 'checkstyle'
  id 'findbugs'
  id 'jacoco'
  id 'com.github.johnrengelman.shadow' version '1.2.4'
}

def defaultEncoding = 'UTF-8'

group = 'keisuke'
//name = 'keisuke'
version = '1.2.3'
//version = '1.x.x-SNAPSHOT'

description = """keisuke"""

repositories {
    mavenCentral()

    //maven { // StepCounter
      //url 'http://amateras.sourceforge.jp/mvn/'
      //artifactUrls 'http://amateras.sourceforge.jp/mvn/'
    //}

    //maven { // fisshplate , stepcounter depends on it
      //url 'https://www.seasar.org/maven/maven2/'
      //artifactUrls 'https://www.seasar.org/maven/maven2/'
    //}
}

dependencies {
    compile 'com.googlecode.java-diff-utils:diffutils:1.3.0'
    compile 'commons-cli:commons-cli:1.3.1'
    compile 'commons-io:commons-io:2.4'
    //compile 'jp.sf.amateras.stepcounter:stepcounter:3.0.3'
    compile 'net.sf.jxls:jxls-core:1.0.5'
    compile 'org.apache.ant:ant:1.9.9'
    compile 'org.apache.poi:poi:3.9'
    //compile 'org.slf4j:slf4j-api:1.7.12'
    testCompile 'junit:junit:4.12'
    testCompile 'org.hamcrest:hamcrest-all:1.3'
    testCompile 'org.jacoco:org.jacoco.agent:0.7.8'
    testCompile 'org.jacoco:org.jacoco.ant:0.7.8'
    checkstyle 'com.puppycrawl.tools:checkstyle:7.8.1'
    findbugs 'com.google.code.findbugs:findbugs:3.0.1'
}

tasks.withType(JavaCompile) {
    options.encoding = defaultEncoding
}
sourceCompatibility = 1.5
targetCompatibility = 1.5

checkstyle {
    toolVersion = '7.8.1'
    configFile = file('config/checkstyle/sun_checks_custom.xml')
    //reportsDir = file("${buildDir}/reports/checkstyle")
    ignoreFailures = true
}

checkstyleTest {
    excludes = ['**/*']
}

findbugs {
    toolVersion = '3.0.1'
    //reportsDir = file("${buildDir}/reports/findbugs")
    ignoreFailures = true
}

def dirPathForOutputOfTestRun = 'test/out'

task cleanAll(type: Delete) {
    delete dirPathForOutputOfTestRun
    dependsOn clean
    doLast {
        println("Delete ${dirPathForOutputOfTestRun}")
    }
}

task makeDirForTest << {
    def outDir = file(dirPathForOutputOfTestRun)
    if (!outDir.exists()) {
        outDir.mkdirs()
        println("makeDir ${dirPathForOutputOfTestRun}")
    }
}

test {
    // The files used as expected data for assertion are encoded with "ja_JP.UTF-8"
    systemProperty 'file.encoding', "${defaultEncoding}"
    systemProperty 'user.language', 'ja'
    systemProperty 'user.country', 'JP'
    //testLogging.showStandardStreams = true
    ignoreFailures = true
    jacoco {
        append = false
        destinationFile = file("${buildDir}/jacoco/Test.exec")
    }
    dependsOn makeDirForTest
}

jacoco {
    toolVersion = '0.7.8'
    //reportsDir = file("${buildDir}/reports/jacoco")
}

jacocoTestReport {
    reports {
        xml.enabled false
        csv.enabled false
        html.enabled true
        html.destination "${buildDir}/reports/jacoco"
    }
    dependsOn test
}

jar {
    baseName = project.name
    version = project.version
    manifest {
        attributes 'Implementation-Title':"${project.name}", 'Implementation-Version':"${project.version}"
    }
}

def suffixFatJar = 'jar-with-dependencies'

shadowJar {
    baseName = project.name
    version = project.version
    classifier "${suffixFatJar}"
    manifest {
        attributes 'Implementation-Title':"${project.name}-${suffixFatJar}", 'Implementation-Version':"${project.version}"
    }
    dependsOn build
}

def suffixSrcJar = 'sources'

task sourcesJar(type: Jar) {
    baseName = project.name
    version = project.version
    classifier = "${suffixSrcJar}"
    from sourceSets.main.allSource
    manifest {
        attributes 'Implementation-Title':"${project.name}-${suffixSrcJar}", 'Implementation-Version':"${project.version}"
    }
    dependsOn build
}

task makeArtifacts(dependsOn: [sourcesJar, shadowJar]) << {
    // do sourcesJar & shadowJar
    println("Artifact = ${project.group}:${project.name}:${project.version}")
}

// Definitions about test data 
def dirPathOfTestDataZip = 'test/archive'
def zipPathOfTestData = 'test/archive/data.zip'
def dirPathOfTestData = 'test/data'
def dirPathDummy = 'test/dummy'

sourceSets {
    testdata {
        java.srcDirs = []
        resources.srcDirs = [dirPathOfTestData]
        output.classesDir = dirPathDummy
        output.resourcesDir = dirPathDummy
    } 
}

compileTestdataJava.deleteAllActions()
//processTestdataResources.deleteAllActions()
testdataClasses.deleteAllActions()

task processTestdataResources(overwrite: true, type: Zip) {
    baseName = 'data'
    version = null
    destinationDir = file('./test/archive')
    from(dirPathOfTestData) {
        include '**'
        includeEmptyDirs = true
    }
    doFirst {
        if (!file(dirPathOfTestData).exists()) {
            println("Fail because it does not exist: ${dirPathOfTestData}")
            throw new Exception("Not exist ${dirPathOfTestData}")
        }
        //if (file(zipPathOfTestData).exists()) {
        //    println("Fail because it already exists: ${zipPathOfTestData}")
        //    throw new Exception("Already exists ${zipPathOfTestData}")
        //}
    }
    doLast {
        println("Archive test data into zip file: ${zipPathOfTestData}")
    }
}

task makeZipOfTestData(dependsOn: processTestdataResources) 

sourceSets {
    testzip {
        java.srcDirs = []
        resources.srcDirs = [dirPathOfTestDataZip]
        output.classesDir = dirPathDummy
        output.resourcesDir = dirPathDummy
    } 
}

compileTestzipJava.deleteAllActions()
//processTestzipResources.deleteAllActions()
testzipClasses.deleteAllActions()

task processTestzipResources(overwrite: true, type: Copy) {
    from(zipTree(zipPathOfTestData)) {
        include '**'
        includeEmptyDirs = true
    }
    into dirPathOfTestData
    doLast {
        println("Extract test data into dir: ${dirPathOfTestData}")
    }
}

task extractTestData(dependsOn: processTestzipResources)


